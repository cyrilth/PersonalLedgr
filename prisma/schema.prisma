generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ── Enums ───────────────────────────────────────────────────────────

enum AccountType {
  CHECKING
  SAVINGS
  CREDIT_CARD
  LOAN
  MORTGAGE
}

enum TransactionType {
  INCOME
  EXPENSE
  TRANSFER
  LOAN_PRINCIPAL
  LOAN_INTEREST
  INTEREST_EARNED
  INTEREST_CHARGED
}

enum TransactionSource {
  MANUAL
  IMPORT
  PLAID
  RECURRING
  SYSTEM
}

enum LoanType {
  MORTGAGE
  AUTO
  STUDENT
  PERSONAL
  BNPL
}

enum RecurringFrequency {
  WEEKLY
  BIWEEKLY
  MONTHLY
  QUARTERLY
  ANNUAL
}

enum InterestLogType {
  CHARGED
  EARNED
}

enum AprRateType {
  STANDARD
  INTRO
  BALANCE_TRANSFER
  CASH_ADVANCE
  PENALTY
  PROMOTIONAL
}

// ── Better Auth Models ──────────────────────────────────────────────

model user {
  id            String    @id
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  sessions       session[]
  authAccounts   authAccount[]
  accounts       Account[]
  transactions   Transaction[]
  recurringBills RecurringBill[]
  budgets        Budget[]
  interestLogs   InterestLog[]
  userCategories UserCategory[]
}

model session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?

  userId String
  user   user   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Renamed from "account" to avoid conflict with finance Account model
model authAccount {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  user      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
}

model verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt
}

// ── Finance Models ──────────────────────────────────────────────────

model Account {
  id          String      @id @default(cuid())
  name        String
  type        AccountType
  balance     Decimal     @default(0) @db.Decimal(12, 2)
  creditLimit Decimal?    @db.Decimal(12, 2)
  owner       String?
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  userId String
  user   user   @relation(fields: [userId], references: [id], onDelete: Cascade)

  transactions      Transaction[]
  creditCardDetails CreditCardDetails?
  aprRates          AprRate[]
  loan              Loan?
  recurringBills    RecurringBill[]
  interestLogs      InterestLog[]

  @@index([userId])
  @@index([userId, type])
}

model CreditCardDetails {
  id                       String  @id @default(cuid())
  statementCloseDay        Int
  paymentDueDay            Int
  gracePeriodDays          Int     @default(25)
  lastStatementBalance     Decimal @default(0) @db.Decimal(12, 2)
  lastStatementPaidInFull  Boolean @default(true)
  minimumPaymentPct        Decimal @default(0.02) @db.Decimal(5, 4)
  minimumPaymentFloor      Decimal @default(25) @db.Decimal(12, 2)

  accountId String  @unique
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

model AprRate {
  id             String      @id @default(cuid())
  rateType       AprRateType
  apr            Decimal     @db.Decimal(6, 4)
  effectiveDate  DateTime
  expirationDate DateTime?
  description    String?
  isActive       Boolean     @default(true)
  createdAt      DateTime    @default(now())

  accountId    String
  account      Account       @relation(fields: [accountId], references: [id], onDelete: Cascade)
  transactions Transaction[]

  @@index([accountId, isActive])
}

model Loan {
  id                 String   @id @default(cuid())
  loanType           LoanType
  originalBalance    Decimal  @db.Decimal(12, 2)
  interestRate       Decimal  @db.Decimal(6, 4)
  termMonths         Int
  startDate          DateTime
  monthlyPayment     Decimal  @db.Decimal(12, 2)
  extraPaymentAmount Decimal  @default(0) @db.Decimal(12, 2)
  paymentDueDay      Int?     // day of month payment is due (1-31)

  // BNPL-specific fields
  totalInstallments      Int?                // total number of payments (e.g., 4)
  completedInstallments  Int                 @default(0) // payments made so far
  installmentFrequency   RecurringFrequency? // BIWEEKLY, WEEKLY, MONTHLY (null = traditional loan)
  nextPaymentDate        DateTime?           // next scheduled payment date
  merchantName           String?             // what was purchased (e.g., "PayPal - Nike Shoes")
  paymentAccountId       String?             // source account for auto-payments

  accountId String  @unique
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
}

model Transaction {
  id          String            @id @default(cuid())
  date        DateTime
  description String
  amount      Decimal           @db.Decimal(12, 2)
  type        TransactionType
  category    String?
  source      TransactionSource @default(MANUAL)
  notes       String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  userId    String
  user      user    @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId String
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Self-referential FK for linked transfers
  linkedTransactionId String?       @unique
  linkedTransaction   Transaction?  @relation("LinkedTransactions", fields: [linkedTransactionId], references: [id])
  linkedBy            Transaction?  @relation("LinkedTransactions")

  // Per-transaction APR rate (credit card purchases)
  aprRateId String?
  aprRate   AprRate? @relation(fields: [aprRateId], references: [id], onDelete: SetNull)

  // Bill payment record (if this transaction is a bill payment)
  billPayment BillPayment?

  @@index([userId, date])
  @@index([accountId, date])
  @@index([userId, type])
  @@index([userId, category])
  @@index([date, amount, description])
}

model RecurringBill {
  id               String             @id @default(cuid())
  name             String
  amount           Decimal            @db.Decimal(12, 2)
  frequency        RecurringFrequency
  dayOfMonth       Int
  isVariableAmount Boolean            @default(false)
  category         String?
  isActive         Boolean            @default(true)
  nextDueDate      DateTime
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  userId    String
  user      user    @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId String
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  billPayments BillPayment[]

  @@index([userId, nextDueDate])
}

model Budget {
  id       String  @id @default(cuid())
  category String
  period   String
  limit    Decimal @db.Decimal(12, 2)

  userId String
  user   user   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, category, period])
  @@index([userId, period])
}

model UserCategory {
  id        String   @id @default(cuid())
  name      String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  userId String
  user   user   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
  @@index([userId, isActive])
}

model InterestLog {
  id     String          @id @default(cuid())
  date   DateTime
  amount Decimal         @db.Decimal(12, 2)
  type   InterestLogType
  notes  String?

  userId    String
  user      user    @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId String
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId, date])
  @@index([userId, date])
}

model BillPayment {
  id              String        @id @default(cuid())
  month           Int
  year            Int
  amount          Decimal       @db.Decimal(12, 2)
  paidAt          DateTime      @default(now())

  recurringBillId String
  recurringBill   RecurringBill @relation(fields: [recurringBillId], references: [id], onDelete: Cascade)

  transactionId   String?       @unique
  transaction     Transaction?  @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@index([recurringBillId, month, year])
  @@index([recurringBillId])
  @@index([year, month])
}
